## Containerization and Orchestration

* I already have a significant amount of experience in this area.

### Cgroups

> A cgroup can be defined as a set of processes whose usage of resources is metered and monitored. The resources can be memory pages, disk i/o, CPU etc. In fact, cgroups are classified based on which resource the limit is imposed on and nature of action taken when a limit is violated.

The component in the cgroup which tracks resource utilization and controls the behaviour of processes in a cgroup is called resource-subsystem or resource controller.

Following is the set of resource controllers and their function according to RHEL’s introduction to cgroups:

blkio — this subsystem sets limits on input/output access to and from block devices such as physical drives (disk, solid state, or USB).
cpu — this subsystem uses the scheduler to provide cgroup processes access to the CPU. cpuacct — this subsystem generates automatic reports on CPU resources used by processes in a cgroup.
cpuset — this subsystem assigns individual CPUs (on a multicore system) and memory nodes to processes in a cgroup.
devices — this subsystem allows or denies access to devices by processes in a cgroup.
freezer — this subsystem suspends or resumes processes in a cgroup.
memory — this subsystem sets limits on memory use by processes in a cgroup and generates automatic reports on memory resources used by those processes.

### Introduction to Containers

* I already have a significant amount of experience with this.
### Containerization with Docker

* I already have a significant amount of experience with this.
### Orchestration with K8s

* I already have a significant amount of experience with this.
### Conclusion

* N/A

## System Calls and Signals

### Interrupt

* Alters the normal execution and flow of a program that can be generated by hardware devices or by the CPU itself.

### Full List of IPC (POSTIX) Signals

https://en.wikipedia.org/wiki/Signal_(IPC)

Includes:

* Keyboards, illegal instructions, abnormal termination, bus error, floating point excpetion, kill signals, invalid memory references, user defined signals, tty's, child stopped or terminated, broken pipe, stack fault on math, etc.

### Sending Signals to Processes

* Via Kill

```
kill -9 367
```

Will kill process 367 with SIGKILL (IPC number 9)

* Via Keyboard

### Handling Signals

* For example, you can use CTRL+C to ssend a SIGINT signal.
* Run the below lines in a python environment.

```
$ python
Python 3.9.5 (default, Sep 21 2021, 16:47:38)
[Clang 12.0.5 (clang-1205.0.22.11)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> import signal
>>> import sys
>>>
>>> #Start of signal_handler function
>>>
>>> def signal_handler(signal, frame):
...         print ('You pressed Ctrl+C!')
...
>>> # End of signal_handler function
>>>
>>> signal.signal(signal.SIGINT, signal_handler)
<built-in function default_int_handler>
>>> while 1:
...     continue
...
^CYou pressed Ctrl+C!
^CYou pressed Ctrl+C!
```

So basically, when you ress Ctrl+C, it sends a signal, which the program reads as SIGINT, via the python signal handler.  To exit the program now we have to do, "CTRL+Z," which sends SIGSTOP.

```
^Z
[1]  + 30093 suspended  python
```

#### wait()

* the wait() system call, can suspend the execution of a parent call until a child has completed.
* SIGCHLD signal is generated which is delivered to the parent by the kernel.
* Child process trace deleted after completed.

This can be used to save system resources.

### System Calls

* These services include, for example, 
* creating a new process, 
* performing I/O, and 
* creating a pipe for interprocess communication.

#### Types of System Calls

* Process Control: These system calls are used to handle tasks related to a process such as process creation, termination,etc.
* File Management: These system calls are used for operations on files such as reading/writing a file.
* Device Management: These system calls are used to deal with devices such as reading/writing into device buffers.
* Information Maintenance: These system calls handle information and its transfer between the operating system and the user program.
* Communication: These system calls are useful for inter-process communication. They are also used for creating and deleting a communication connection.

